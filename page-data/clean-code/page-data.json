{"componentChunkName":"component---src-templates-blog-post-jsx","path":"/clean-code/","result":{"data":{"site":{"siteMetadata":{"title":"Abhishek Sah"}},"markdownRemark":{"id":"8e026ad7-f220-5982-a368-8fc01cf1b90c","excerpt":"Writing clean code is what you must do in order to call yourself a professional. There is no reasonable excuse for doing anything less than your best! The best…","html":"<blockquote>\n<p>Writing clean code is what you must do in order to call yourself a professional. There is no reasonable excuse for doing anything less than your best!</p>\n</blockquote>\n<p>The best measurement of code quality is WTFs/minute!</p>\n<p>So let’s get straight into actionable insights on how to reduce the above metric!</p>\n<h3>Meaningful Names</h3>\n<p>Naming is hard! Few things to take care while naming your variables and methods.</p>\n<ul>\n<li>Use intention revealing names</li>\n<li>Avoid disinformation</li>\n<li>Make meaningful distinctions</li>\n<li>Use pronounceable names</li>\n<li>Use searchable names</li>\n<li>Follow common conventions of the programming language you are using</li>\n<li>Class names should be noun phrases</li>\n<li>Method names should be verb phrases ​</li>\n</ul>\n<h3>Functions</h3>\n<ul>\n<li>Functions should be small. 4–5 lines is a very good metric. But it is very much specific to your choice of programming language. But the lesser, the better.</li>\n<li>Functions should do one thing only.</li>\n<li>There should be only one level of abstraction per function. For example, avoid doing tasks such as inserting employee object to a list and generating the employee payslip in a single function. Because those are a different level of abstractions. Also violates the doing one thing principle.</li>\n<li>Avoid switch statements. Switch statements imply your function is doing more than one thing based on some condition. Think of a better way to express your thoughts(Polymorphism maybe?)</li>\n<li>Use descriptive names</li>\n<li>An optimal number of arguments to a function is zero. In the worst case, you can have one or two arguments. But more than two is a strict red alert. If a function has more than two arguments if possible make them a new class (if possible)!</li>\n<li>Never use flag arguments. Flag arguments mean your function is doing two things. You need to split your function.</li>\n<li>Don’t have side effects associated with calling your function. No hidden-changes. Clearly, do one thing!</li>\n<li>Return value objects. Value objects are objects whose instance variables never change once they have been set in the constructor. Value objects biggest advantage is that they save you the trouble of nonorthogonality.</li>\n<li>Prefer exception to return error codes. Use try-catch in place of if-else!</li>\n<li>DRY — Don’t Repeat Yourself! Eliminate duplication at all cost.</li>\n</ul>\n<h3>Comments​</h3>\n<ul>\n<li>Best comments are no comments — Comment show your inability to write clean code that expresses your intent.</li>\n</ul>\n<h3>Formatting</h3>\n<ul>\n<li>Indentation ​is most important.</li>\n<li>There shouldn’t be any blank lines in between function. A blank line should mark a logical separation in methods, classes etc.</li>\n<li>Instance variables should be placed at the starting of the class on top of methods.</li>\n<li>The caller should be above the callee. (But language-specific!)</li>\n<li>Focus on readability by giving appropriate vertical density.</li>\n</ul>\n<h3>Objects and Data Structure​</h3>\n<p>What is the difference between Objects and Data Structure?</p>\n<ul>\n<li>Objects hide their data behind abstractions and expose functions that operate on that data.</li>\n<li>Objects do not expose data. Rather express their data in abstract terms.</li>\n<li>Data Structures expose their data and have no meaningful functions.</li>\n</ul>\n<p>Sometimes we need to use data structure, sometimes we need to objects and sometimes both. So we should be able to tell</p>\n<p>With objects, we need to follow the Law of Demeter. Law of Demeter says that a method <em>f</em> of Class <em>C</em> should only call methods of</p>\n<ul>\n<li><em>C</em></li>\n<li>An object created by <em>f</em></li>\n<li>An object passed as an argument</li>\n<li>An object held as an instance variable of <em>C</em></li>\n</ul>\n<p>Failing law of Demeter implies a function knows many things. Split that function into multiple functions. It could be split into several one line functions that delegate the task to other methods.</p>\n<h3>Error Handling</h3>\n<ul>\n<li>Use exceptions rather than error codes ​</li>\n</ul>\n<h3>Unit Test</h3>\n<ul>\n<li>TDD is encouraged to be followed.</li>\n<li>Tests must be clean (Readability). Don’t treat tests as second class citizens. Your tests should also be written following all the clean code conventions. Test code is as important as production code.</li>\n<li>Test coverage should be always high.</li>\n<li>Try to have only one assertion per test. If not then try to minimize the number of assertions per test. There should be a single concept per test.</li>\n</ul>\n<p>Follow the F.I.R.S.T acronym with unit tests.</p>\n<p>F — Tests should run fast</p>\n<p>I — Tests shouldn’t depend on each other</p>\n<p>R — Tests should be repeatable in any environment</p>\n<p>S — Tests should be self-validating (Test should have a boolean output)</p>\n<p>T — Tests should be written Timely ​</p>\n<h3>Classes​</h3>\n<ul>\n<li>Never have a public variable —this implies bad encapsulation. You should protect your classes privacy from the outer world.</li>\n<li>Classes should be small. It should be smaller than that.</li>\n<li>One class should have an only responsibility — SRP: Single Responsibility Principle. SRP means a class should have only one reason to change.</li>\n<li>Class Name should describe what responsibility it fulfils.</li>\n<li>A class should have high Cohesion. Maximum cohesion is achieved when each instance variable is used by each method.</li>\n<li>When classes lose cohesion split them. It means SRP is being violated. Abstractions are getting mixed.</li>\n</ul>\n<h3>Emergence​</h3>\n<ul>\n<li>Systems that are not testable are not verifiable if not verifiable then not deployable. RUN ALL THE TESTS</li>\n<li>Refactoring is something which will help your system emerge. When refactoring you should remove duplication. When you refactor try to be more expressive with your intent. Impose SRP on your modules. Refactor them if SRP is being violated. ​</li>\n</ul>\n<h3>Few more tips!</h3>\n<ul>\n<li>Building your project(compilation, testing, packaging) should be easy. One should be able to build via a single command or a few commands only. It should bot involve various different checkpoints.</li>\n<li>All test should run with one command.</li>\n<li>Avoid multiple languages in one source file. ​</li>\n<li>Avoid Surprises ​</li>\n<li>Never overwrite Safety. This means to take care of your warnings. Simply suppressing your warnings could result in Chernobyl! A disaster.</li>\n<li>Eliminate duplication. Follow DRY: Don’t Repeat yourself</li>\n<li>Don’t Mix levels of Abstraction. Follow the law of Demeter.​</li>\n<li>Always remove dead code.</li>\n<li>Always maintain consistency ​throughout your project.</li>\n<li>Be as expressive as possible.​</li>\n<li>Don’t mix responsibilities.</li>\n<li>Make logical dependencies physical.\n​</li>\n<li>Prefer Polymorphism to if-else, switch cases ​</li>\n<li>Encapsulate conditionals, boundary conditions, edges cases</li>\n</ul>\n<hr>\n<p>So that was a brief summary of writing clean code.\nThanks for reading. Feel free to connect with me on <a href=\"https://twitter.com/whoAbhishekSah\">Twitter</a> for any conversations on this.</p>","frontmatter":{"title":"Clean code","date":"August 04, 2019","description":"BOOK"}}},"pageContext":{"slug":"/clean-code/","previous":{"fields":{"slug":"/pragmatic-programmer/"},"frontmatter":{"title":"Pragmatic Programmer"}},"next":{"fields":{"slug":"/TDD-by-kent-beck/"},"frontmatter":{"title":"TDD by Kent Beck"}}}}}